#!/bin/bash
#
# Usage: shell-build [-kpv] <definition> <prefix>
#        shell-build --definitions
#        shell-build --version
#
#   -k/--keep        Do not remove source tree after installation
#   -p/--patch       Apply a patch from stdin before building
#   -v/--verbose     Verbose mode: print compilation status to stdout
#   -4/--ipv4        Resolve names to IPv4 addresses only
#   -6/--ipv6        Resolve names to IPv6 addresses only
#   --definitions    List all built-in definitions
#   --version        Show version of shell-build
#   -g/--debug       Build a debug version
#

SHELL_BUILD_VERSION="20160602"

OLDIFS="$IFS"

set -E
exec 3<&2 # preserve original stderr at fd 3


lib() {
  parse_options() {
    OPTIONS=()
    ARGUMENTS=()
    local arg option index

    for arg in "$@"; do
      if [ "${arg:0:1}" = "-" ]; then
        if [ "${arg:1:1}" = "-" ]; then
          OPTIONS[${#OPTIONS[*]}]="${arg:2}"
        else
          index=1
          while option="${arg:$index:1}"; do
            [ -n "$option" ] || break
            OPTIONS[${#OPTIONS[*]}]="$option"
            index=$(($index+1))
          done
        fi
      else
        ARGUMENTS[${#ARGUMENTS[*]}]="$arg"
      fi
    done
  }

  if [ "$1" == "--$FUNCNAME" ]; then
    declare -f "$FUNCNAME"
    echo "$FUNCNAME \"\$1\";"
    exit
  fi
}
lib "$1"


resolve_link() {
  $(type -p greadlink readlink | head -1) "$1"
}

abs_dirname() {
  local path="$1"

  # Use a subshell to avoid modifying the current path
  (
  while [ -n "$path" ]; do
    cd "${path%/*}"
    local name="${path##*/}"
    path="$(resolve_link "$name" || true)"
  done

  pwd
  )
}

capitalize() {
  printf "%s" "$1" | tr a-z A-Z
}

sanitize() {
  printf "%s" "$1" | sed "s/[^A-Za-z0-9.-]/_/g; s/__*/_/g"
}

colorize() {
  if [ -t 1 ]; then printf "\e[%sm%s\e[m" "$1" "$2"
  else echo -n "$2"
  fi
}

os_information() {
  if type -p lsb_release >/dev/null; then
    lsb_release -sir | xargs echo
  elif type -p sw_vers >/dev/null; then
    echo "OS X $(sw_vers -productVersion)"
  elif [ -r /etc/os-release ]; then
    source /etc/os-release
    echo "$NAME" $VERSION_ID
  else
    local os="$(cat /etc/{centos,redhat,fedora,system}-release /etc/debian_version 2>/dev/null | head -1)"
    echo "${os:-$(uname -sr)}"
  fi
}

is_mac() {
  [ "$(uname -s)" = "Darwin" ] || return 1
  [ $# -eq 0 ] || [ "$(osx_version)" "$@" ]
}

#  9.1  -> 901
# 10.9  -> 1009
# 10.10 -> 1010
osx_version() {
  local -a ver
  IFS=. ver=( `sw_vers -productVersion` )
  IFS="$OLDIFS"
  echo $(( ${ver[0]}*100 + ${ver[1]} ))
}

build_failed() {
  { echo
    colorize 1 "BUILD FAILED"
    echo " ($(os_information) using $(version))"
    echo

    if ! rmdir "${BUILD_PATH}" 2>/dev/null; then
      echo "Inspect or clean up the working tree at ${BUILD_PATH}"

      if file_is_not_empty "$LOG_PATH"; then
        colorize 33 "Results logged to ${LOG_PATH}"
        printf "\n\n"
        echo "Last 10 log lines:"
        tail -n 10 "$LOG_PATH"
      fi
    fi
  } >&3
  exit 1
}

file_is_not_empty() {
  local filename="$1"
  local line_count="$(wc -l "$filename" 2>/dev/null || true)"

  if [ -n "$line_count" ]; then
    words=( $line_count )
    [ "${words[0]}" -gt 0 ]
  else
    return 1
  fi
}

num_cpu_cores() {
  local num
  case "$(uname -s)" in
  Darwin | *BSD )
    num="$(sysctl -n hw.ncpu 2>/dev/null || true)"
    ;;
  * )
    num="$({ getconf _NPROCESSORS_ONLN ||
             grep -c ^processor /proc/cpuinfo; } 2>/dev/null)"
    num="${num#0}"
    ;;
  esac
  echo "${num:-2}"
}

install_package() {
  install_package_using "tarball" 1 "$@"
}

install_nightly_package() {
  install_package_using "nightly_tarball" 2 "$@"
}

install_git() {
  install_package_using "git" 2 "$@"
}

install_hg() {
  install_package_using "hg" 2 "$@"
}

install_svn() {
  install_package_using "svn" 2 "$@"
}

install_jar() {
  install_package_using "jar" 1 "$@"
}

install_zip() {
  install_package_using "zip" 1 "$@"
}

install_script() {
  install_package_using "script" 1 "$@"
}

install_package_using() {
  local package_type="$1"
  local package_type_nargs="$2"
  local package_name="$3"
  shift 3

  local fetch_args=( "$package_name" "${@:1:$package_type_nargs}" )
  local make_args=( "$package_name" )
  local arg last_arg

  for arg in "${@:$(( $package_type_nargs + 1 ))}"; do
    if [ "$last_arg" = "--if" ]; then
      "$arg" || return 0
    elif [ "$arg" != "--if" ]; then
      make_args["${#make_args[@]}"]="$arg"
    fi
    last_arg="$arg"
  done

  pushd "$BUILD_PATH" >&4
  "fetch_${package_type}" "${fetch_args[@]}"
  make_package "${make_args[@]}"
  popd >&4

  { echo "Installed ${package_name} to ${PREFIX_PATH}"
    echo
  } >&2
}

make_package() {
  local package_name="$1"
  shift

  pushd "$package_name" >&4
  setup_builtin_patches "$package_name"
  before_install_package "$package_name"
  build_package "$package_name" $*
  after_install_package "$package_name"
  cleanup_builtin_patches "$package_name"
  fix_directory_permissions
  popd >&4
}

compute_sha2() {
  local output
  if type shasum &>/dev/null; then
    output="$(shasum -a 256 -b)" || return 1
    echo "${output% *}"
  elif type openssl &>/dev/null; then
    local openssl="$(command -v "$(brew --prefix openssl 2>/dev/null || true)"/bin/openssl openssl | head -1)"
    output="$("$openssl" dgst -sha256 2>/dev/null)" || return 1
    echo "${output##* }"
  elif type sha256sum &>/dev/null; then
    output="$(sha256sum -b)" || return 1
    echo "${output%% *}"
  else
    return 1
  fi
}

compute_md5() {
  local output
  if type md5 &>/dev/null; then
    md5 -q
  elif type openssl &>/dev/null; then
    output="$(openssl md5)" || return 1
    echo "${output##* }"
  elif type md5sum &>/dev/null; then
    output="$(md5sum -b)" || return 1
    echo "${output%% *}"
  else
    return 1
  fi
}

has_checksum_support() {
  local checksum_command="$1"
  local has_checksum_var="HAS_CHECKSUM_SUPPORT_${checksum_command}"

  if [ -z "${!has_checksum_var+defined}" ]; then
    printf -v "$has_checksum_var" "$(echo test | "$checksum_command" >/dev/null; echo $?)"
  fi
  return "${!has_checksum_var}"
}

verify_checksum() {
  local checksum_command
  local filename="$1"
  local expected_checksum="$(echo "$2" | tr [A-Z] [a-z])"

  # If the specified filename doesn't exist, return success
  [ -e "$filename" ] || return 0

  case "${#expected_checksum}" in
  0) return 0 ;; # empty checksum; return success
  32) checksum_command="compute_md5" ;;
  64) checksum_command="compute_sha2" ;;
  *)
    { echo
      echo "unexpected checksum length: ${#expected_checksum} (${expected_checksum})"
      echo "expected 0 (no checksum), 32 (MD5), or 64 (SHA2-256)"
      echo
    } >&4
    return 1 ;;
  esac

  # If chosen provided checksum algorithm isn't supported, return success
  has_checksum_support "$checksum_command" || return 0

  # If the computed checksum is empty, return failure
  local computed_checksum=`echo "$($checksum_command < "$filename")" | tr [A-Z] [a-z]`
  [ -n "$computed_checksum" ] || return 1

  if [ "$expected_checksum" != "$computed_checksum" ]; then
    { echo
      echo "checksum mismatch: ${filename} (file is corrupt)"
      echo "expected $expected_checksum, got $computed_checksum"
      echo
    } >&4
    return 1
  fi
}

http() {
  local method="$1"
  local url="$2"
  local file="$3"
  [ -n "$url" ] || return 1

  if type aria2c &>/dev/null; then
    "http_${method}_aria2c" "$url" "$file"
  elif type curl &>/dev/null; then
    "http_${method}_curl" "$url" "$file"
  elif type wget &>/dev/null; then
    "http_${method}_wget" "$url" "$file"
  else
    echo "error: please install \`aria2c\`, \`curl\` or \`wget\` and try again" >&2
    exit 1
  fi
}

http_head_aria2c() {
  aria2c --dry-run --no-conf=true ${ARIA2_OPTS} "$1" >&4 2>&1
}

http_get_aria2c() {
  local out="${2:-$(mktemp "out.XXXXXX")}"
  if aria2c --allow-overwrite=true --no-conf=true -o "${out}" ${ARIA2_OPTS} "$1" >&4; then
    [ -n "$2" ] || cat "${out}"
  else
    false
  fi
}

http_head_curl() {
  curl -qsILf ${CURL_OPTS} "$1" >&4 2>&1
}

http_get_curl() {
  curl -q -o "${2:--}" -sSLf ${CURL_OPTS} "$1"
}

http_head_wget() {
  wget -q --spider ${WGET_OPTS} "$1" >&4 2>&1
}

http_get_wget() {
  wget -nv ${WGET_OPTS} -O "${2:--}" "$1"
}

extract_cpio_gz() {
  gzip -cd "$1" | cpio -idmv
}

fetch_tarball() {
  local package_name="$1"
  local package_url="$2"
  local mirror_url
  local checksum

  if [ "$package_url" != "${package_url/\#}" ]; then
    checksum="${package_url#*#}"
    package_url="${package_url%%#*}"

    if [ -n "$SHELL_BUILD_MIRROR_URL" ]; then
      if [[ -z "$SHELL_BUILD_DEFAULT_MIRROR" || $package_url != */www.shell.org/* ]]; then
        mirror_url="${SHELL_BUILD_MIRROR_URL}/$checksum"
      fi
    fi
  fi

  local tar_command="tar"
  local tar_args="xzf"
  local package_filename="${package_name}.tar.gz"

  if [ "$package_url" != "${package_url%bz2}" ]; then
    if ! type -p bzip2 >/dev/null; then
      echo "warning: bzip2 not found; consider installing \`bzip2\` package" >&4
    fi
    package_filename="${package_filename%.gz}.bz2"
    tar_args="${tar_args/z/j}"
  fi

   if [ "$package_url" != "${package_url%xz}" ]; then
     if ! type -p xz >/dev/null; then
      echo "warning: xz not found; consider installing \`xz\` package" >&4
     fi
     package_filename="${package_filename%.gz}.xz"
     tar_args="${tar_args/z/J}"
   fi

   if [ "$package_url" != "${package_url%cpgz}" ]; then
     if ! type -p cpio >/dev/null; then
      echo "warning: cpio not found; consider installing \`cpio\` package" >&4
     fi
     package_filename="${package_filename%.gz}.cpgz"
     tar_command="extract_cpio_gz"
     tar_args=""
   fi

   if [ "$package_url" != "${package_url%cpio.gz}" ]; then
     if ! type -p cpio >/dev/null; then
      echo "warning: cpio not found; consider installing \`cpio\` package" >&4
     fi
     package_filename="${package_filename%.tar.gz}.cpio.gz"
     tar_command="extract_cpio_gz"
     tar_args=""
   fi

  if ! reuse_existing_tarball "$package_filename" "$checksum"; then
    local tarball_filename=$(basename $package_url)
    echo "Downloading ${tarball_filename}..." >&2
    http head "$mirror_url" &&
    download_tarball "$mirror_url" "$package_filename" "$checksum" ||
    download_tarball "$package_url" "$package_filename" "$checksum"
  fi

  { if $tar_command $tar_args "$package_filename"; then
      if [ -z "$KEEP_BUILD_PATH" ]; then
        rm -f "$package_filename"
      else
        true
      fi
    fi
  } >&4 2>&1
}

fetch_nightly_tarball() {
  local package_name="$1"
  local package_url="$2"
  local package_pattern="$3"
  fetch_tarball "$1" "$2"
  if [ ! -e "${package_name}" ]; then
    local nightly_package_name="$(echo ${package_pattern})"
    if [ -e "${nightly_package_name}" ]; then
      ln -fs "${nightly_package_name}" "${package_name}"
    fi
  fi
}

reuse_existing_tarball() {
  local package_filename="$1"
  local checksum="$2"

  # Reuse existing file in build location
  if [ -e "$package_filename" ] && verify_checksum "$package_filename" "$checksum"; then
    return 0
  fi

  # Reuse previously downloaded file in cache location
  [ -n "$SHELL_BUILD_CACHE_PATH" ] || return 1
  local cached_package_filename="${SHELL_BUILD_CACHE_PATH}/$package_filename"

  [ -e "$cached_package_filename" ] || return 1
  verify_checksum "$cached_package_filename" "$checksum" >&4 2>&1 || return 1
  ln -s "$cached_package_filename" "$package_filename" >&4 2>&1 || return 1
}

download_tarball() {
  local package_url="$1"
  [ -n "$package_url" ] || return 1

  local package_filename="$2"
  local checksum="$3"

  echo "-> $package_url" >&2

  if http get "$package_url" "$package_filename" >&4 2>&1; then
    verify_checksum "$package_filename" "$checksum" >&4 2>&1 || return 1
  else
    echo "error: failed to download $package_filename" >&2
    return 1
  fi

  if [ -n "$SHELL_BUILD_CACHE_PATH" ]; then
    local cached_package_filename="${SHELL_BUILD_CACHE_PATH}/$package_filename"
    { mv "$package_filename" "$cached_package_filename"
      ln -s "$cached_package_filename" "$package_filename"
    } >&4 2>&1 || return 1
  fi
}

has_tar_xz_support() {
  tar Jc /dev/null 1>/dev/null 2>&1
}

fetch_git() {
  local package_name="$1"
  local git_url="$2"
  local git_ref="$3"

  echo "Cloning ${git_url}..." >&2

  if type git &>/dev/null; then
    if [ -n "$SHELL_BUILD_CACHE_PATH" ]; then
      pushd "$SHELL_BUILD_CACHE_PATH" >&4
      local clone_name="$(sanitize "$git_url")"
      if [ -e "${clone_name}" ]; then
        { cd "${clone_name}"
          git fetch --force "$git_url" "+${git_ref}:${git_ref}"
        } >&4 2>&1
      else
        git clone --bare --branch "$git_ref" "$git_url" "${clone_name}" >&4 2>&1
      fi
      git_url="$SHELL_BUILD_CACHE_PATH/${clone_name}"
      popd >&4
    fi

    if [ -e "${package_name}" ]; then
      ( cd "${package_name}"
        git fetch --depth 1 origin "+${git_ref}"
        git checkout -q -B "$git_ref" "origin/${git_ref}"
      ) >&4 2>&1
    else
      git clone --depth 1 --branch "$git_ref" "$git_url" "${package_name}" >&4 2>&1
    fi
  else
    echo "error: please install \`git\` and try again" >&2
    exit 1
  fi
}

fetch_hg() {
  local package_name="$1"
  local hg_url="$2"
  local hg_ref="$3"

  echo "Cloning ${hg_url}..." >&2

  if type hg &>/dev/null; then
    if [ -n "$SHELL_BUILD_CACHE_PATH" ]; then
      pushd "$SHELL_BUILD_CACHE_PATH" >&4
      local clone_name="$(sanitize "$hg_url")"
      if [ -e "${clone_name}" ]; then
        { cd "${clone_name}"
          hg pull --force "$hg_url"
        } >&4 2>&1
      else
        { hg clone --branch "$hg_ref" "$hg_url" "${clone_name}"
          cd "${clone_name}"
          hg update null
        } >&4 2>&1
      fi
      hg_url="$SHELL_BUILD_CACHE_PATH/${clone_name}"
      popd >&4
    fi

    hg clone --branch "$hg_ref" "$hg_url" "${package_name}" >&4 2>&1
  else
    echo "error: please install \`mercurial\` and try again" >&2
    exit 1
  fi
}

fetch_svn() {
  local package_name="$1"
  local svn_url="$2"
  local svn_rev="$3"

  echo "Checking out ${svn_url}..." >&2

  if type svn &>/dev/null; then
    svn co -r "$svn_rev" "$svn_url" "${package_name}" >&4 2>&1
  elif type svnlite &>/dev/null; then
    svnlite co -r "$svn_rev" "$svn_url" "${package_name}" >&4 2>&1
  else
    echo "error: please install Subversion and try again" >&2
    exit 1
  fi
}

fetch_jar() {
  local package_name="$1"
  local package_url="$2"
  local mirror_url
  local checksum

  if [ "$package_url" != "${package_url/\#}" ]; then
    checksum="${package_url#*#}"
    package_url="${package_url%%#*}"

    if [ -n "$SHELL_BUILD_MIRROR_URL" ]; then
      mirror_url="${SHELL_BUILD_MIRROR_URL}/$checksum"
    fi
  fi

  local package_filename="${package_name}.jar"

  if ! reuse_existing_tarball "$package_filename" "$checksum"; then
    echo "Downloading ${package_filename}..." >&2
    http head "$mirror_url" &&
    download_tarball "$mirror_url" "$package_filename" "$checksum" ||
    download_tarball "$package_url" "$package_filename" "$checksum"
  fi

  # Must use full path to jar and destination directory:
  #   http://bugs.jython.org/issue2350
  { if $JAVA -jar "$PWD/${package_name}.jar" -s -d "$PWD/${package_name}"; then
      if [ -z "$KEEP_BUILD_PATH" ]; then
        rm -f "$package_filename"
      else
        true
      fi
    fi
  } >&4 2>&1
}

fetch_zip() {
  local package_name="$1"
  local package_url="$2"
  local mirror_url
  local checksum

  if [ "$package_url" != "${package_url/\#}" ]; then
    checksum="${package_url#*#}"
    package_url="${package_url%%#*}"

    if [ -n "$SHELL_BUILD_MIRROR_URL" ]; then
      mirror_url="${SHELL_BUILD_MIRROR_URL}/$checksum"
    fi
  fi

  local package_filename="${package_name}.zip"

  if ! reuse_existing_tarball "$package_filename" "$checksum"; then
    echo "Downloading ${package_filename}..." >&2
    http head "$mirror_url" &&
    download_tarball "$mirror_url" "$package_filename" "$checksum" ||
    download_tarball "$package_url" "$package_filename" "$checksum"
  fi

  { if unzip "$package_filename"; then
      if [ -z "$KEEP_BUILD_PATH" ]; then
        rm -f "$package_filename"
      else
        true
      fi
    fi
  } >&4 2>&1
}

fetch_script() {
  local package_name="$1"
  local package_url="$2"
  local mirror_url
  local checksum

  if [ "$package_url" != "${package_url/\#}" ]; then
    checksum="${package_url#*#}"
    package_url="${package_url%%#*}"

    if [ -n "$SHELL_BUILD_MIRROR_URL" ]; then
      mirror_url="${SHELL_BUILD_MIRROR_URL}/$checksum"
    fi
  fi

  local package_filename="${package_name}.sh" # TODO: extract suffix from ${package_url}

  if ! reuse_existing_tarball "$package_filename" "$checksum"; then
    echo "Downloading ${package_filename}..." >&2
    http head "$mirror_url" &&
    download_tarball "$mirror_url" "$package_filename" "$checksum" ||
    download_tarball "$package_url" "$package_filename" "$checksum"
  fi

  mkdir -p "$(dirname "${package_name}/${package_filename}")"
  mv -f "${package_filename}" "${package_name}/${package_filename}"
}

build_package() {
  local package_name="$1"
  shift

  if [ "$#" -eq 0 ]; then
    local commands="standard"
  else
    local commands="$*"
  fi

  echo "Installing ${package_name}..." >&2

  [ -n "$HAS_PATCH" ] && apply_shell_patch "$package_name"

  for command in $commands; do
    "build_package_${command}" "$package_name"
  done
}

package_option() {
  local package_name="$1"
  local command_name="$2"
  local variable="$(capitalize "${package_name}_${command_name}")_OPTS_ARRAY"
  local array="$variable[@]"
  shift 2
  local value=( "${!array}" "$@" )
  eval "$variable=( \"\${value[@]}\" )"
}

build_package_warn_eol() {
  local package_name="$1"

  { echo
    echo "WARNING: $package_name is past its end of life and is now unsupported."
    echo "It no longer receives bug fixes or critical security updates."
    echo
  } >&3
}

build_package_warn_unsupported() {
  local package_name="$1"

  { echo
    echo "WARNING: $package_name is nearing its end of life."
    echo "It only receives critical security updates, no bug fixes."
    echo
  } >&3
}

build_package_standard_build() {
  local package_name="$1"

  if [ "${MAKEOPTS+defined}" ]; then
    MAKE_OPTS="$MAKEOPTS"
  elif [ -z "${MAKE_OPTS+defined}" ]; then
    MAKE_OPTS="-j $(num_cpu_cores)"
  fi

  # Support YAML_CONFIGURE_OPTS, SHELL_CONFIGURE_OPTS, etc.
  local package_var_name="$(capitalize "${package_name%%-*}")"
  local PACKAGE_CONFIGURE="${package_var_name}_CONFIGURE"
  local PACKAGE_PREFIX_PATH="${package_var_name}_PREFIX_PATH"
  local PACKAGE_CONFIGURE_OPTS="${package_var_name}_CONFIGURE_OPTS"
  local PACKAGE_CONFIGURE_OPTS_ARRAY="${package_var_name}_CONFIGURE_OPTS_ARRAY[@]"
  local PACKAGE_MAKE_OPTS="${package_var_name}_MAKE_OPTS"
  local PACKAGE_MAKE_OPTS_ARRAY="${package_var_name}_MAKE_OPTS_ARRAY[@]"
  local PACKAGE_CFLAGS="${package_var_name}_CFLAGS"

  if [ "$package_var_name" = "SHELL" ]; then
      use_homebrew_readline || use_freebsd_pkg ||true
  fi

  ( if [ "${CFLAGS+defined}" ] || [ "${!PACKAGE_CFLAGS+defined}" ]; then
      export CFLAGS="$CFLAGS ${!PACKAGE_CFLAGS}"
    fi
    if [ -z "$CC" ] && is_mac -ge 1010; then
      export CC=clang
    fi
    ${!PACKAGE_CONFIGURE:-./configure} --prefix="${!PACKAGE_PREFIX_PATH:-$PREFIX_PATH}" \
      $CONFIGURE_OPTS ${!PACKAGE_CONFIGURE_OPTS} "${!PACKAGE_CONFIGURE_OPTS_ARRAY}" || return 1
  ) >&4 2>&1

  { "$MAKE" $MAKE_OPTS ${!PACKAGE_MAKE_OPTS} "${!PACKAGE_MAKE_OPTS_ARRAY}"
  } >&4 2>&1
}

build_package_standard_install() {
  local package_name="$1"
  local package_var_name="$(capitalize "${package_name%%-*}")"

  local PACKAGE_MAKE_INSTALL_OPTS="${package_var_name}_MAKE_INSTALL_OPTS"
  local PACKAGE_MAKE_INSTALL_OPTS_ARRAY="${package_var_name}_MAKE_INSTALL_OPTS_ARRAY[@]"
  local PACKAGE_MAKE_INSTALL_TARGET="${package_var_name}_MAKE_INSTALL_TARGET"

  { "$MAKE" "${!PACKAGE_MAKE_INSTALL_TARGET:-install}" $MAKE_INSTALL_OPTS ${!PACKAGE_MAKE_INSTALL_OPTS} "${!PACKAGE_MAKE_INSTALL_OPTS_ARRAY}"
  } >&4 2>&1
}

# Backword Compatibility for standard function
build_package_standard() {
  build_package_standard_build "$@"
  build_package_standard_install "$@"
}

build_package_autogen() {
  local package_name="$1"
  local package_var_name="$(capitalize "${package_name%%-*}")"
  local PACKAGE_AUTOGEN="${package_var_name}_AUTOGEN"
  { ${!PACKAGE_AUTOGEN:-./autogen.sh}
  } >&4 2>&1
}

build_package_aclocal() {
  { aclocal
  } >&4 2>&1
}

build_package_autoheader() {
  { autoheader
  } >&4 2>&1
}

build_package_automake() {
  { automake --add-missing
  } >&4 2>&1
}

build_package_autoconf() {
  { autoconf
  } >&4 2>&1
}

build_package_build_script() {
  local package_name="$1"
  local package_var_name="$(capitalize "${package_name%%-*}")"
  local PACKAGE_BUILD_SCRIPT="${package_var_name}_BUILD_SCRIPT"
  { chmod +x ${!PACKAGE_BUILD_SCRIPT:-./Build.sh}
    ${!PACKAGE_BUILD_SCRIPT:-./Build.sh}
  } >&4 2>&1
}

build_package_bin_install() {
  local package_name="$1"
  local package_var_name="$(capitalize "${package_name%%-*}")"
  local PACKAGE_BIN="${package_var_name}_BIN"
  { mkdir -p "${PREFIX_PATH}/bin"
    cp ${!PACKAGE_BIN:-${package_name%%-*}} "${PREFIX_PATH}/bin"
    chmod +x "${PREFIX_PATH}/bin/mksh"
  }
}

remove_windows_files() {
  cd "$PREFIX_PATH"
  rm -f bin/*.exe bin/*.dll bin/*.bat bin/jruby.sh
}

build_package_copy() {
  mkdir -p "$PREFIX_PATH"
  cp -fR . "$PREFIX_PATH"
}

before_install_package() {
  local stub=1
}

after_install_package() {
  local stub=1
}

setup_builtin_patches() {
  local package_name="$1"
  local package_patch_path="${DEFINITION_PATH%/*}/patches/${DEFINITION_PATH##*/}/${package_name}"

  ORIG_HAS_PATCH="$HAS_PATCH"
# Apply built-in patches if patch was not given from stdin
  if [ -z "$HAS_PATCH" ] && [ -d "${package_patch_path}" ]; then
    { find "${package_patch_path}" -maxdepth 1 -type f
    } 2>/dev/null | sort | xargs cat 1>"${package_name}.patch"
    exec <&-
    exec <"${package_name}.patch"
    HAS_PATCH=true
  fi
}

cleanup_builtin_patches() {
  local package_name="$1"
  rm -f "${package_name}.patch"
  HAS_PATCH="$ORIG_HAS_PATCH"
}

fix_directory_permissions() {
  # Ensure installed directories are not world-writable to avoid Bundler warnings
  find "$PREFIX_PATH" -type d \( -perm -020 -o -perm -002 \) -exec chmod go-w {} \;
}

require_java7() {
  local version="$(java -version 2>&1 | grep '\(java\|openjdk\) version' | head -1)"
  if [[ $version != *1.[789]* ]]; then
    colorize 1 "ERROR" >&3
    echo ": Java 7 required. Please install a 1.7-compatible JRE." >&3
    return 1
  fi
}

require_gcc() {
  local gcc="$(locate_gcc || true)"

  if [ -z "$gcc" ]; then
    { echo
      colorize 1 "ERROR"
      echo ": This package must be compiled with GCC, but shell-build couldn't"
      echo "find a suitable \`gcc\` executable on your system. Please install GCC"
      echo "and try again."
      echo

      if is_mac; then
        colorize 1 "DETAILS"
        echo ": Apple no longer includes the official GCC compiler with Xcode"
        echo "as of version 4.2. Instead, the \`gcc\` executable is a symlink to"
        echo "\`llvm-gcc\`, a modified version of GCC which outputs LLVM bytecode."
        echo

        colorize 1 "TO FIX THE PROBLEM"
        if type brew &>/dev/null; then
          echo ": Install Homebrew's apple-gcc42 package with this"
          echo -n "command: "
          colorize 4 "brew tap homebrew/dupes ; brew install apple-gcc42"
        else
          echo ": Install the official GCC compiler using these"
          echo -n "packages: "
          colorize 4 "https://github.com/kennethreitz/osx-gcc-installer/downloads"
        fi
      fi
    } >&3
    return 1
  fi

  export CC="$gcc"
  if is_mac -ge 1010; then
    export MACOSX_DEPLOYMENT_TARGET=10.9
  fi
}

locate_gcc() {
  local gcc gccs
  IFS=: gccs=($(gccs_in_path))
  IFS="$OLDIFS"

  verify_gcc "$CC" ||
  verify_gcc "$(command -v gcc || true)" || {
    for gcc in "${gccs[@]}"; do
      verify_gcc "$gcc" && break || true
    done
  }

  return 1
}

gccs_in_path() {
  local gcc path paths
  local gccs=()
  IFS=: paths=($PATH)
  IFS="$OLDIFS"

  shopt -s nullglob
  for path in "${paths[@]}"; do
    for gcc in "$path"/gcc-*; do
      gccs["${#gccs[@]}"]="$gcc"
    done
  done
  shopt -u nullglob

  printf :%s "${gccs[@]}"
}

verify_gcc() {
  local gcc="$1"
  if [ -z "$gcc" ]; then
    return 1
  fi

  local version="$("$gcc" --version 2>/dev/null || true)"
  if [ -z "$version" ]; then
    return 1
  fi

  if echo "$version" | grep LLVM >/dev/null; then
    return 1
  fi

  echo "$gcc"
}

require_llvm() {
  local llvm_version="$1"
  if is_mac -ge 1010; then
    if [[ "$SHELL_CONFIGURE_OPTS" != *--llvm-* ]]; then
      case "$llvm_version" in
      3.2 )
        package_option shell configure --prebuilt-name="llvm-3.2-x86_64-apple-darwin13.tar.bz2"
        ;;
      3.[56] )
        local llvm_config="$(locate_llvm "$llvm_version")"
        if [ -n "$llvm_config" ]; then
          package_option shell configure --llvm-config="$llvm_config"
        else
          local homebrew_package="llvm@$llvm_version"
          { echo
            colorize 1 "ERROR"
            echo ": Rubinius will not be able to compile using Apple's LLVM-based "
            echo "build tools on OS X. You will need to install LLVM $llvm_version first."
            echo
            colorize 1 "TO FIX THE PROBLEM"
            echo ": Install Homebrew's llvm package with this"
            echo -n "command: "
            colorize 4 "brew install $homebrew_package"
            echo
          } >&3
          return 1
        fi
        ;;
      esac
    fi
  fi
}

locate_llvm() {
  local llvm_version="$1"
  local package llvm_config
  shopt -s nullglob
  for package in `brew list 2>/dev/null | grep "^llvm"`; do
    llvm_config="$(echo "$(brew --prefix "$package")/bin/llvm-config"*)"
    if [ -n "$llvm_config" ] && [[ "$("$llvm_config" --version)" = "$llvm_version"* ]]; then
      echo "$llvm_config"
      break
    fi
  done
  shopt -u nullglob
}

require_java() {
  local java="$(command -v java || true)"

  if [ -z "$java" ]; then
    { echo
      colorize 1 "ERROR"
      echo ": This package must be installed with java, but shell-build couldn't"
      echo "find a suitable \`java\` executable on your system. Please install Java"
      echo "and try again."
      echo
    } >&3
    return 1
  fi

  export JAVA="$java"
}

require_distro() {
  for arg; do
    if [[ "$(cat /etc/issue 2>/dev/null || true)" == "$arg"* ]]; then
      return 0
    fi
  done
  { echo
    colorize 1 "WARNING"
    echo ": This binary distribution is built for the following distro(s): $@."
    echo "installed binary may not run expectedly on other platforms."
    echo
  } >&2
  return 1
}

configured_with_package_dir() {
  local package_var_name="$(capitalize "$1")"
  shift 1
  local PACKAGE_CONFIGURE_OPTS="${package_var_name}_CONFIGURE_OPTS"
  local PACKAGE_CONFIGURE_OPTS_ARRAY="${package_var_name}_MAKE_OPTS_ARRAY[@]"
  local arg flag
  for arg in ${CONFIGURE_OPTS} ${!PACKAGE_CONFIGURE_OPTS} "${!PACKAGE_CONFIGURE_OPTS_ARRAY}"; do
    if [[ "$arg" == "CPPFLAGS="* ]]; then
      for flag in ${CPPFLAGS} ${arg##CPPFLAGS=}; do
        if [[ "$flag" == "-I"* ]]; then
          local header
          for header in "$@"; do
            if [ -e "${flag##-I}/${header#/}" ]; then
              return 0
            fi
          done
        fi
      done
    fi
  done
  return 1
}

needs_yaml() {
  ! configured_with_package_dir "shell" "yaml.h" &&
  ! use_homebrew_yaml
}

use_homebrew_yaml() {
  local libdir="$(brew --prefix libyaml 2>/dev/null || true)"
  if [ -d "$libdir" ]; then
    echo "shell-build: use libyaml from homebrew"
    export CPPFLAGS="-I$libdir/include ${CPPFLAGS}"
    export LDFLAGS="-L$libdir/lib ${LDFLAGS}"
  else
    return 1
  fi
}

use_freebsd_pkg() {
  # check if FreeBSD
  if [ "FreeBSD" = "$(uname -s)" ]; then
    # use openssl if installed from Ports Collection
    if [ -f /usr/local/include/openssl/ssl.h ]; then
      package_option ruby configure --with-openssl-dir="/usr/local"
    fi

    # check if 11-R or later
    release="$(uname -r)"
    if [ "${release%%.*}" -ge 11 ]; then
      # prefers readline to compile most of ruby versions
      if pkg info -e readline > /dev/null; then
        # use readline from Ports Collection
        package_option ruby configure --with-readline-dir="/usr/local"
      elif pkg info -e libedit > /dev/null; then
        # use libedit from Ports Collection
        package_option ruby configure --enable-libedit
        package_option ruby configure --with-libedit-dir="/usr/local"
      fi
    fi
  fi
}

has_broken_mac_readline() {
  # Mac OS X 10.4 has broken readline.
  # https://github.com/shenv/shenv/issues/23
  is_mac &&
  ! configured_with_package_dir "shell" "readline/rlconf.h" &&
  ! use_homebrew_readline
}

use_homebrew_readline() {
  if ! configured_with_package_dir "shell" "readline/rlconf.h"; then
    local libdir="$(brew --prefix readline 2>/dev/null || true)"
    if [ -d "$libdir" ]; then
      echo "shell-build: use readline from homebrew"
      export CPPFLAGS="-I$libdir/include ${CPPFLAGS}"
      export LDFLAGS="-L$libdir/lib ${LDFLAGS}"
    else
      return 1
    fi
  fi
}

has_broken_mac_openssl() {
  is_mac || return 1
  local openssl_version="$(/usr/bin/openssl version 2>/dev/null || true)"
  [[ $openssl_version = "OpenSSL 0.9.8"?* || $openssl_version = "LibreSSL"* ]] &&
  ! use_homebrew_openssl
}

use_homebrew_openssl() {
  local ssldir="$(brew --prefix openssl 2>/dev/null || true)"
  if [ -d "$ssldir" ]; then
    echo "shell-build: use openssl from homebrew"
    export CPPFLAGS="-I$ssldir/include ${CPPFLAGS}"
    export LDFLAGS="-L$ssldir/lib ${LDFLAGS}"
  else
    return 1
  fi
}

build_package_mac_openssl() {
  # Install to a subdirectory since we don't want shims for bin/openssl.
  OPENSSL_PREFIX_PATH="${PREFIX_PATH}/openssl"

  # Put openssl.conf, certs, etc in ~/.shenv/versions/*/openssl/ssl
  OPENSSLDIR="${OPENSSLDIR:-$OPENSSL_PREFIX_PATH/ssl}"

  # Tell shell to use this openssl for its extension.
  export CPPFLAGS="-I${OPENSSL_PREFIX_PATH}/include ${CPPFLAGS}"
  export LDFLAGS="-L${OPENSSL_PREFIX_PATH}/lib ${LDFLAGS}"

  # Hint OpenSSL that we prefer a 64-bit build.
  export KERNEL_BITS="64"
  OPENSSL_CONFIGURE="${OPENSSL_CONFIGURE:-./config}"

  # Compile a shared lib with zlib dynamically linked, no kerberos.
  package_option openssl configure --openssldir="$OPENSSLDIR" zlib-dynamic no-ssl2 no-ssl3 no-krb5 shared

  # Default MAKE_OPTS are -j 2 which can confuse the build. Thankfully, make
  # gives precedence to the last -j option, so we can override that.
  package_option openssl make -j 1

  build_package_standard "$@"

  # Extract root certs from the system keychain in .pem format and rehash.
  local pem_file="$OPENSSLDIR/cert.pem"
  security find-certificate -a -p /Library/Keychains/System.keychain > "$pem_file"
  security find-certificate -a -p /System/Library/Keychains/SystemRootCertificates.keychain >> "$pem_file"
}

# Post-install check that the openssl extension was built.
build_package_verify_openssl() {
  "$RUBY_BIN" -e 'begin
    require "openssl"
  rescue LoadError
    $stderr.puts "The Ruby openssl extension was not compiled. Missing the OpenSSL lib?"
    $stderr.puts "Configure options used:"
    require "rbconfig"; require "shellwords"
    RbConfig::CONFIG.fetch("configure_args").shellsplit.each { |arg| $stderr.puts "  #{arg}" }
    exit 1
  end' >&4 2>&1
}

# Ensure that directories listed in LDFLAGS exist
build_package_ldflags_dirs() {
  local arg dir
  set - $LDFLAGS
  while [ $# -gt 0 ]; do
    dir=""
    case "$1" in
    -L  ) dir="$2" ;;
    -L* ) dir="${1#-L}" ;;
    esac
    [ -z "$dir" ] || mkdir -p "$dir"
    shift 1
  done
}

build_package_enable_shared() {
    package_option shell configure --enable-shared
}

build_package_auto_tcltk() {
  if is_mac && [ ! -d /usr/include/X11 ]; then
    if [ -d /opt/X11/include ]; then
      if [[ "$CPPFLAGS" != *-I/opt/X11/include* ]]; then
        export CPPFLAGS="-I/opt/X11/include $CPPFLAGS"
      fi
    else
      package_option shell configure --without-tk
    fi
  fi
}

apply_shell_patch() {
  local patchfile
  case "$1" in
  shell-* | jython-* | pypy-* | stackless-* )
    patchfile="$(mktemp "${TMP}/shell-patch.XXXXXX")"
    cat "${2:--}" >"$patchfile"

    local striplevel=0
    grep -q '^diff --git a/' "$patchfile" && striplevel=1
    patch -p$striplevel --force -i "$patchfile"
    ;;
  esac
}

build_package_symlink_version_suffix() {
  if [[ "$SHELL_CONFIGURE_OPTS" == *"--enable-framework"* ]]; then
    if [ -e "${PREFIX_PATH}/bin" ]; then
      # Always create `bin` as symlink to framework path if the version was built with `--enable-frameowrk` (#590)
      rm -rf "${PREFIX_PATH}/bin.orig"
      mv -f "${PREFIX_PATH}/bin" "${PREFIX_PATH}/bin.orig"
    fi
    # Only symlinks are installed in ${PREFIX_PATH}/bin
    ln -fs "${PREFIX_PATH}/shell.framework/Versions/Current/bin" "${PREFIX_PATH}/bin"
  fi

  # Not create symlinks on `altinstall` (#255)
  if [[ "$SHELL_MAKE_INSTALL_TARGET" != *"altinstall"* ]]; then
    shopt -s nullglob
    local version_bin="$(ls -1 "${PREFIX_PATH}/bin/shell"* | grep '[0-9]$' | sort | tail -1)"
    suffix="$(basename "${version_bin}" | sed -e 's/^shell//')"
    if [ -n "${suffix}" ]; then
      local file link
      for file in "${PREFIX_PATH}/bin"/*; do
        unset link
        case "${file}" in
        */"shell${suffix}-config" )
          # Symlink `shellX.Y-config` to `shell-config` if `shell-config` is missing (#296)
          link="${file%/*}/shell-config"
        ;;
        */*"-${suffix}" )
          link="${file%%-${suffix}}"
        ;;
        */*"${suffix}" )
          link="${file%%${suffix}}"
        ;;
        esac
        if [ -n "$link" ] && [ ! -e "$link" ]; then
          ( cd "${file%/*}" && ln -fs "${file##*/}" "${link##*/}" )
        fi
      done
    fi
    shopt -u nullglob
  fi
}

verify_shell() {
  build_package_symlink_version_suffix

  if [ ! -x "${SHELL_BIN}" ]; then
    { colorize 1 "ERROR"
      echo ": invalid shell executable: ${SHELL_BIN}"
      echo
      echo "The shell-build script could not find proper executable of shell after successful build."
      echo "Please open an issue for future improvements."
      echo "https://github.com/shenv/shenv/issues"
      return 1
    } >&3
  fi
}

version() {
  local git_revision
  # Read the revision from git if the remote points to "shell-build" repository
  if GIT_DIR="$SHELL_BUILD_INSTALL_PREFIX/../../.git" git remote -v 2>/dev/null | grep -q /shenv; then
    git_revision="$(GIT_DIR="$SHELL_BUILD_INSTALL_PREFIX/../../.git" git describe --tags HEAD 2>/dev/null || true)"
    git_revision="${git_revision#v}"
  fi
  echo "shell-build ${git_revision:-$SHELL_BUILD_VERSION}"
}

usage() {
  sed -ne '/^#/!q;s/.\{1,2\}//;1,2d;p' < "$0"
  [ -z "$1" ] || exit "$1"
}

list_definitions() {
  { for DEFINITION_DIR in "${SHELL_BUILD_DEFINITIONS[@]}"; do
      [ -d "$DEFINITION_DIR" ] && find "$DEFINITION_DIR" -maxdepth 1 -type f -print0 | xargs -0 -n 1 basename 2>/dev/null
    done
  } | sort_versions | uniq
}

sort_versions() {
  sed 'h; s/[+-]/./g; s/.p\([[:digit:]]\)/.z.\1/; s/$/.z/; G; s/\n/ /' | \
    LC_ALL=C sort -t. -k 1,1 -k 2,2n -k 3,3n -k 4,4n -k 5,5n | awk '{print $2}'
}


unset VERBOSE
unset KEEP_BUILD_PATH
unset HAS_PATCH
unset DEBUG
unset IPV4
unset IPV6

SHELL_BUILD_INSTALL_PREFIX="$(abs_dirname "$0")/.."

IFS=: SHELL_BUILD_DEFINITIONS=($SHELL_BUILD_DEFINITIONS ${SHELL_BUILD_ROOT:-$SHELL_BUILD_INSTALL_PREFIX}/share/shell-build)
IFS="$OLDIFS"

parse_options "$@"

for option in "${OPTIONS[@]}"; do
  case "$option" in
  "h" | "help" )
    version
    echo
    usage 0
    ;;
  "definitions" )
    list_definitions
    exit 0
    ;;
  "k" | "keep" )
    KEEP_BUILD_PATH=true
    ;;
  "v" | "verbose" )
    VERBOSE=true
    ;;
  "p" | "patch" )
    HAS_PATCH=true
    ;;
  "g" | "debug" )
    DEBUG=true
    # Disable optimization (#808)
    SHELL_CFLAGS="-O0 ${SHELL_CFLAGS}"
    ;;
  "4" | "ipv4")
    IPV4=true
    ;;
  "6" | "ipv6")
    IPV6=true
    ;;
  "version" )
    version
    exit 0
    ;;
  esac
done

[ "${#ARGUMENTS[@]}" -eq 2 ] || usage 1 >&2

DEFINITION_PATH="${ARGUMENTS[0]}"
if [ -z "$DEFINITION_PATH" ]; then
  usage 1 >&2
elif [ ! -f "$DEFINITION_PATH" ]; then
  for DEFINITION_DIR in "${SHELL_BUILD_DEFINITIONS[@]}"; do
    if [ -f "${DEFINITION_DIR}/${DEFINITION_PATH}" ]; then
      DEFINITION_PATH="${DEFINITION_DIR}/${DEFINITION_PATH}"
      break
    fi
  done

  if [ ! -f "$DEFINITION_PATH" ]; then
    echo "shell-build: definition not found: ${DEFINITION_PATH}" >&2
    exit 2
  fi
fi

PREFIX_PATH="${ARGUMENTS[1]}"
if [ -z "$PREFIX_PATH" ]; then
  usage 1 >&2
elif [ "${PREFIX_PATH#/}" = "$PREFIX_PATH" ]; then
  PREFIX_PATH="${PWD}/${PREFIX_PATH}"
fi

if [ -z "$TMPDIR" ]; then
  TMP="/tmp"
else
  TMP="${TMPDIR%/}"
fi

# Check if TMPDIR is accessible and can hold executables.
tmp_executable="${TMP}/shell-build-test.$$"
noexec=""
if mkdir -p "$TMP" && touch "$tmp_executable" 2>/dev/null; then
  cat > "$tmp_executable" <<-EOF
	#!${BASH}
	exit 0
	EOF
  chmod +x "$tmp_executable"
else
  echo "shell-build: TMPDIR=$TMP is set to a non-accessible location" >&2
  exit 1
fi
"$tmp_executable" 2>/dev/null || noexec=1
rm -f "$tmp_executable"
if [ -n "$noexec" ]; then
  echo "shell-build: TMPDIR=$TMP cannot hold executables (partition possibly mounted with \`noexec\`)" >&2
  exit 1
fi

## Apply following work around, if gcc is not installed.
#if [ -z "$(locate_gcc)" ]; then
#  # Work around warnings building Ruby 2.0 on Clang 2.x:
#  # pass -Wno-error=shorten-64-to-32 if the compiler accepts it.
#  #
#  # When we set CFLAGS, Ruby won't apply its default flags, though. Since clang
#  # builds 1.9.x and 2.x only, where -O3 is default, we can safely set that flag.
#  # Ensure it's the first flag since later flags take precedence.
#  if "${CC:-cc}" -x c /dev/null -E -Wno-error=shorten-64-to-32 &>/dev/null; then
#    RUBY_CFLAGS="-O3 -Wno-error=shorten-64-to-32 $RUBY_CFLAGS"
#  fi
#fi

if [ -z "$MAKE" ]; then
  if [ "FreeBSD" = "$(uname -s)" ]; then
    if [ "$(echo $1 | sed 's/-.*$//')" = "jruby" ]; then
      export MAKE="gmake"
    else
      if [ "$(uname -r | sed 's/[^[:digit:]].*//')" -lt 10 ]; then
        export MAKE="gmake"
      else
        export MAKE="make"
      fi
    fi
  else
    export MAKE="make"
  fi
fi

if [ -n "$SHELL_BUILD_CACHE_PATH" ] && [ -d "$SHELL_BUILD_CACHE_PATH" ]; then
  SHELL_BUILD_CACHE_PATH="${SHELL_BUILD_CACHE_PATH%/}"
else
  unset SHELL_BUILD_CACHE_PATH
fi

if [ -z "$SHELL_BUILD_MIRROR_URL" ]; then
  SHELL_BUILD_MIRROR_URL="https://shenv.github.io/shells"
  SHELL_BUILD_DEFAULT_MIRROR=1
else
  SHELL_BUILD_MIRROR_URL="${SHELL_BUILD_MIRROR_URL%/}"
  SHELL_BUILD_DEFAULT_MIRROR=
fi

if [ -n "$SHELL_BUILD_SKIP_MIRROR" ] || ! has_checksum_support compute_sha2; then
  unset SHELL_BUILD_MIRROR_URL
fi

ARIA2_OPTS="${SHELL_BUILD_ARIA2_OPTS} ${IPV4+--disable-ipv6=true} ${IPV6+--disable-ipv6=false}"
CURL_OPTS="${SHELL_BUILD_CURL_OPTS} ${IPV4+--ipv4} ${IPV6+--ipv6}"
WGET_OPTS="${SHELL_BUILD_WGET_OPTS} ${IPV4+--inet4-only} ${IPV6+--inet6-only}"

# Add an option to build a debug version of shell (#11)
if [ -n "$DEBUG" ]; then
  package_option shell configure --with-pydebug
fi

# shell-build: Specify `--libdir` on configure to fix build on openSUSE (#36)
package_option shell configure --libdir="${PREFIX_PATH}/lib"

# shell-build: Set `RPATH` if `--enable-shared` was given (#65, #66, #82)
if [[ "$CONFIGURE_OPTS" == *"--enable-shared"* ]] || [[ "$SHELL_CONFIGURE_OPTS" == *"--enable-shared"* ]]; then
  # The ld on Darwin embeds the full paths to each dylib by default
  if [[ "$LDFLAGS" != *"-rpath="* ]] && ! is_mac; then
    export LDFLAGS="-Wl,-rpath=${PREFIX_PATH}/lib ${LDFLAGS}"
  fi
fi

# shell-build: Set `RPATH` if --shared` was given for PyPy (#244)
if [[ "$PYPY_OPTS" == *"--shared"* ]]; then
  export LDFLAGS="-Wl,-rpath=${PREFIX_PATH}/lib ${LDFLAGS}"
fi

# Add support for framework installation (`--enable-framework`) of Cshell (#55, #99)
if [[ "$SHELL_CONFIGURE_OPTS" == *"--enable-framework"* ]]; then
  if ! is_mac; then
    echo "shell-build: framework installation is not supported." >&2
    exit 1
  fi
  create_framework_dirs() {
    local version="$(echo "$1" | sed -E 's/^[^0-9]*([0-9]+\.[0-9]+).*$/\1/')"
    mkdir -p "${PREFIX_PATH}/shell.framework/Versions/${version}"
    ( cd "${PREFIX_PATH}/shell.framework/Versions" && ln -fs "${version}" "Current")
    local path
    for path in include lib share; do
      mkdir -p "${PREFIX_PATH}/shell.framework/Versions/Current/${path}"
      ln -fs "${PREFIX_PATH}/shell.framework/Versions/Current/${path}" "${PREFIX_PATH}/${path}"
    done
  }
  create_framework_dirs "${DEFINITION_PATH##*/}"
  package_option shell configure --enable-framework="${PREFIX_PATH}"
fi

# Build against universal SDK (#219, #220)
if [[ "$SHELL_CONFIGURE_OPTS" == *"--enable-universalsdk"* ]]; then
  if ! is_mac; then
    echo "shell-build: universal installation is not supported." >&2
    exit 1
  fi
  package_option shell configure --enable-universalsdk=/ --with-universal-archs=intel
fi

# Compile with `--enable-unicode=ucs4` by default (#257)
# if [[ "$SHELL_CONFIGURE_OPTS" != *"--enable-unicode="* ]]; then
#   if ! is_mac; then
#     # Skip specifying `--enable-unicode` for Cshell 3.3+ (#912)
#     case "${DEFINITION_PATH##*/}" in
#     "2."* | \
#     "3.0" | "3.0."* | "3.0-"* | \
#     "3.1" | "3.1."* | "3.1-"* | \
#     "3.2" | "3.2."* | "3.2-"* )
#       package_option shell configure --enable-unicode=ucs4
#       ;;
#     esac
#   fi
# fi

# SSL Certificate error with older wget that does not support Server Name Indication (#60)
if ! command -v curl 1>/dev/null 2>&1 && [[ "$(wget --version 2>/dev/null || true)" = "GNU Wget 1.1"[0-3]* ]]; then
  echo "shell-build: wget (< 1.14) doesn't support Server Name Indication. Please install curl (>= 7.18.1) and try again" >&2
  exit 1
fi

# Unset `PIP_REQUIRE_VENV` during build (#216)
# unset PIP_REQUIRE_VENV
# unset PIP_REQUIRE_VIRTUALENV

# pydistutils.cfg may corrupt install location of shell libraries (#35, #111)
# if [ -e "$HOME/.pydistutils.cfg" ]; then
#   { colorize 1 "WARNING"
#     echo ": Please make sure you remove any previous custom paths from your $HOME/.pydistutils.cfg file."
#   } >&2
# fi

# Download specified version of ez_setup.py/get-pip.py (#202)
# if [ -n "${SETUPTOOLS_VERSION}" ]; then
#   EZ_SETUP_URL="https://bitbucket.org/pypa/setuptools/raw/${SETUPTOOLS_VERSION}/ez_setup.py"
# fi
# if [ -n "${PIP_VERSION}" ]; then
#   GET_PIP_URL="https://raw.githubusercontent.com/pypa/pip/${PIP_VERSION}/contrib/get-pip.py"
# fi

# Set MACOSX_DEPLOYMENT_TARGET from the product version of OS X (#219, #220)
if is_mac; then
  if [ -z "${MACOSX_DEPLOYMENT_TARGET}" ]; then
    MACOS_VERSION="$(sw_vers -productVersion 2>/dev/null || true)"
    MACOS_VERSION_ARRAY=(${MACOS_VERSION//\./ })
    if [ "${#MACOS_VERSION_ARRAY[@]}" -ge 2 ]; then
      export MACOSX_DEPLOYMENT_TARGET="${MACOS_VERSION_ARRAY[0]}.${MACOS_VERSION_ARRAY[1]}"
    fi
  fi
fi

shell_bin_suffix() {
  local version_name version_info
  case "$1" in
  2.* | 3.* )
    version_name="$1"
    version_name="${version_name%-dev}"
    version_name="${version_name%-rc*}"
    version_name="${version_name%rc*}"
    version_info=(${version_name//./ })
    echo "${version_info[0]}.${version_info[1]}"
    ;;
  stackless-2.* | stackless-3.* )
    version_name="${1#stackless-}"
    version_name="${version_name%-dev}"
    version_name="${version_name%-rc*}"
    version_name="${version_name%rc*}"
    version_info=(${version_name//./ })
    echo "${version_info[0]}.${version_info[1]}"
    ;;
  esac
}

SEED="$(date "+%Y%m%d%H%M%S").$$"
LOG_PATH="${TMP}/shell-build.${SEED}.log"
SHELL_BIN="${PREFIX_PATH}/bin/shell$(shell_bin_suffix "${DEFINITION_PATH##*/}")"
CWD="$(pwd)"

if [ -z "$SHELL_BUILD_BUILD_PATH" ]; then
  BUILD_PATH="${TMP}/shell-build.${SEED}"
else
  BUILD_PATH="$SHELL_BUILD_BUILD_PATH"
fi

exec 4<> "$LOG_PATH" # open the log file at fd 4
if [ -n "$VERBOSE" ]; then
  tail -f "$LOG_PATH" &
  TAIL_PID=$!
  trap "kill $TAIL_PID" SIGINT SIGTERM EXIT
fi

export LDFLAGS="-L${PREFIX_PATH}/lib ${LDFLAGS}"
export CPPFLAGS="-I${PREFIX_PATH}/include ${CPPFLAGS}"

unset SHELLHOME
unset SHELLPATH

trap build_failed ERR
mkdir -p "$BUILD_PATH"
source "$DEFINITION_PATH"
[ -z "${KEEP_BUILD_PATH}" ] && rm -fr "$BUILD_PATH"
trap - ERR
